{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "roambc-synapse-workspace"
		},
		"AzureDataLakeStorage_servicePrincipalCredential": {
			"type": "secureString",
			"metadata": "Secure string for 'servicePrincipalCredential' of 'AzureDataLakeStorage'"
		},
		"roambc-synapse-workspace-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'roambc-synapse-workspace-WorkspaceDefaultSqlServer'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:roambc-synapse-workspace.sql.azuresynapse.net,1433;Initial Catalog=@{linkedService().DBName}"
		},
		"AzureDataLakeStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://bc2adlsroamstorage.dfs.core.windows.net"
		},
		"AzureDataLakeStorage_properties_typeProperties_tenant": {
			"type": "string",
			"defaultValue": "15a21561-2767-4ad5-b518-89c3ff410cb4"
		},
		"AzureDataLakeStorage_properties_typeProperties_servicePrincipalId": {
			"type": "string",
			"defaultValue": "aeb1be25-efa0-41bd-8f9e-206f1f9cbe53"
		},
		"roambc-synapse-workspace-WorkspaceDefaultStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://bc2adlsroamstorage.dfs.core.windows.net"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/Consolidation_AllEntities')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Entities",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "deltasManifest_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									}
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "For each entity",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Entities",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Entities').output.value[0].entities",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "ConsolidateNewDeltas",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "Consolidation_CheckForDeltas",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"containerName": {
												"value": "@pipeline().parameters.containerName",
												"type": "Expression"
											},
											"entityName": {
												"value": "@item().entityName",
												"type": "Expression"
											},
											"deleteDeltas": {
												"value": "@pipeline().parameters.deleteDeltas",
												"type": "Expression"
											},
											"sparkpoolName": {
												"value": "@pipeline().parameters.sparkpoolName",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"deleteDeltas": {
						"type": "bool",
						"defaultValue": false
					},
					"sparkpoolName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Microsoft.Synapse/workspaces/pipelines"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/deltasManifest_dataset')]",
				"[concat(variables('workspaceId'), '/pipelines/Consolidation_CheckForDeltas')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Consolidation_CheckForDeltas')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "CheckEntityExistenceInDeltas",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "deltas_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"exists"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "IfEntityExists",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "CheckEntityExistenceInDeltas",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@activity('CheckEntityExistenceInDeltas').output.exists",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailIfEntityNotFound",
									"description": "Fails the current iteration over the entities in the deltas manifest if no directory is found for the current entity",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": {
											"value": "@concat('Entity with name ', pipeline().parameters.entityName, ' was found in the deltas.manifest.cdm.json but no directory with that name was found in ', pipeline().parameters.containerName, '/deltas/. This may be the case if no new deltas have been exported.')",
											"type": "Expression"
										},
										"errorCode": "404"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "ConsolidateEntity",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "Consolidation_OneEntity",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"containerName": {
												"value": "@pipeline().parameters.containerName",
												"type": "Expression"
											},
											"entityName": {
												"value": "@pipeline().parameters.entityName",
												"type": "Expression"
											},
											"deleteDeltas": {
												"value": "@pipeline().parameters.deleteDeltas",
												"type": "Expression"
											},
											"sparkpoolName": {
												"value": "@pipeline().parameters.sparkpoolName",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					},
					"deleteDeltas": {
						"type": "bool"
					},
					"sparkpoolName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Microsoft.Synapse/workspaces/pipelines"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/deltas_dataset')]",
				"[concat(variables('workspaceId'), '/pipelines/Consolidation_OneEntity')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Consolidation_OneEntity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ConsolidationDF_staging",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Check data format valid",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "EnsureStagingIsEmpty",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Filtered on Company field",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "Consolidation_flow",
								"type": "DataFlowReference",
								"parameters": {
									"containerName": {
										"value": "'@{pipeline().parameters.containerName}'",
										"type": "Expression"
									},
									"entityName": {
										"value": "'@{pipeline().parameters.entityName}'",
										"type": "Expression"
									},
									"dataFormat": {
										"value": "'@{variables('dataFormat')}'",
										"type": "Expression"
									},
									"perCompanyEntity": {
										"value": "@equals(\n    activity('Filtered on Company field').output.FilteredItemsCount, \n    1\n)",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"Deltas": {},
									"CurrentData": {},
									"StagingParquet": {},
									"StagingCSV": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "DeleteData",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "ConsolidationDF_staging",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "CheckEntityExistenceInData",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "data_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "IfDeleteDeltas",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Copy staging to data",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@pipeline().parameters.deleteDeltas",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "DeleteDeltas",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "deltas_dataset",
											"type": "DatasetReference",
											"parameters": {
												"containerName": {
													"value": "@pipeline().parameters.containerName",
													"type": "Expression"
												},
												"entityName": {
													"value": "@pipeline().parameters.entityName",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								}
							]
						}
					},
					{
						"name": "Lookup Data Manifest",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "dataManifest_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									}
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Filtered on entity",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "Lookup Data Manifest",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup data manifest').output.value[0].entities",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().entityName, pipeline().parameters.entityName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Entity found",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Filtered on entity",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(\n    activity('Filtered on entity').output.FilteredItemsCount, \n    1\n)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Entity not found",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": {
											"value": "@concat(\n    'Entity ', \n    pipeline().parameters.entityName, \n    ' either duplicated or not found in the data manifest.'\n)",
											"type": "Expression"
										},
										"errorCode": "400"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Set trait reference",
									"type": "SetVariable",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"variableName": "traitReference",
										"value": {
											"value": "@string(activity('Filtered on entity').output.value[0].dataPartitionPatterns[0].exhibitsTraits[0].traitReference)\n",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Check data format valid",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Entity found",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@startswith(variables('traitReference'), variables('traitReferencePrefix'))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Bad data format",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": {
											"value": "@concat('Entity ', pipeline().parameters.entityName, ' does not have a valid trait reference in the data manifest.')",
											"type": "Expression"
										},
										"errorCode": "400"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Set data format",
									"type": "SetVariable",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"variableName": "dataFormat",
										"value": {
											"value": "@replace(\n    variables('traitReference'), \n    variables('traitReferencePrefix'),\n    ''\n)",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Copy staging to data",
						"type": "Switch",
						"dependsOn": [
							{
								"activity": "DeleteData",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"on": {
								"value": "@variables('dataFormat')",
								"type": "Expression"
							},
							"cases": [
								{
									"value": "CSV",
									"activities": [
										{
											"name": "Copy CSV",
											"type": "Copy",
											"dependsOn": [],
											"policy": {
												"timeout": "7.00:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"source": {
													"type": "DelimitedTextSource",
													"storeSettings": {
														"type": "AzureBlobFSReadSettings",
														"recursive": true,
														"wildcardFileName": "*.csv",
														"enablePartitionDiscovery": false
													},
													"formatSettings": {
														"type": "DelimitedTextReadSettings"
													}
												},
												"sink": {
													"type": "DelimitedTextSink",
													"storeSettings": {
														"type": "AzureBlobFSWriteSettings"
													},
													"formatSettings": {
														"type": "DelimitedTextWriteSettings",
														"quoteAllText": true,
														"fileExtension": ".txt"
													}
												},
												"enableStaging": false,
												"translator": {
													"type": "TabularTranslator",
													"typeConversion": true,
													"typeConversionSettings": {
														"allowDataTruncation": true,
														"treatBooleanAsNumber": false
													}
												}
											},
											"inputs": [
												{
													"referenceName": "staging_dataset",
													"type": "DatasetReference",
													"parameters": {
														"containerName": {
															"value": "@pipeline().parameters.containerName",
															"type": "Expression"
														},
														"entityName": {
															"value": "@pipeline().parameters.entityName",
															"type": "Expression"
														}
													}
												}
											],
											"outputs": [
												{
													"referenceName": "data_dataset",
													"type": "DatasetReference",
													"parameters": {
														"containerName": {
															"value": "@pipeline().parameters.containerName",
															"type": "Expression"
														},
														"entityName": {
															"value": "@pipeline().parameters.entityName",
															"type": "Expression"
														}
													}
												}
											]
										}
									]
								},
								{
									"value": "parquet",
									"activities": [
										{
											"name": "Copy parquet",
											"type": "Copy",
											"dependsOn": [],
											"policy": {
												"timeout": "7.00:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"source": {
													"type": "DelimitedTextSource",
													"storeSettings": {
														"type": "AzureBlobFSReadSettings",
														"recursive": true,
														"wildcardFileName": "*.parquet",
														"enablePartitionDiscovery": false
													},
													"formatSettings": {
														"type": "DelimitedTextReadSettings"
													}
												},
												"sink": {
													"type": "DelimitedTextSink",
													"storeSettings": {
														"type": "AzureBlobFSWriteSettings"
													},
													"formatSettings": {
														"type": "DelimitedTextWriteSettings",
														"quoteAllText": true,
														"fileExtension": ".txt"
													}
												},
												"enableStaging": false,
												"translator": {
													"type": "TabularTranslator",
													"typeConversion": true,
													"typeConversionSettings": {
														"allowDataTruncation": true,
														"treatBooleanAsNumber": false
													}
												}
											},
											"inputs": [
												{
													"referenceName": "staging_dataset",
													"type": "DatasetReference",
													"parameters": {
														"containerName": {
															"value": "@pipeline().parameters.containerName",
															"type": "Expression"
														},
														"entityName": {
															"value": "@pipeline().parameters.entityName",
															"type": "Expression"
														}
													}
												}
											],
											"outputs": [
												{
													"referenceName": "data_dataset",
													"type": "DatasetReference",
													"parameters": {
														"containerName": {
															"value": "@pipeline().parameters.containerName",
															"type": "Expression"
														},
														"entityName": {
															"value": "@pipeline().parameters.entityName",
															"type": "Expression"
														}
													}
												}
											]
										}
									]
								}
							],
							"defaultActivities": [
								{
									"name": "Trait reference not supported",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": {
											"value": "@concat(\n    'Trait reference ',\n    variables('traitReference'),\n    ' for entity ',\n    pipeline().parameters.entityName,\n    ' not supported.'\n)",
											"type": "Expression"
										},
										"errorCode": "400"
									}
								}
							]
						}
					},
					{
						"name": "EnsureStagingIsEmpty",
						"type": "Delete",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "staging_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Delete staging",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Copy staging to data",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "staging_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Lookup entity json",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Entity found",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "entity_dataset",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Filtered on Company field",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "Lookup entity json",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup entity json').output.value[0].definitions[0].hasAttributes",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().name, '$Company')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "SparkTableConditions",
						"description": "Checks whether a new Spark table should be created. \nThree conditions need to be met.\n1. The pipeline parameter sparkpoolName may not be empty.\n2. The data format needs to be parquet.\n3. The entity must not yet exist in the data folder.",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Copy staging to data",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@and(\n    and(\n        equals(variables('dataFormat'), 'parquet'),\n        not(\n            empty(pipeline().parameters.sparkpoolName)\n        )\n    ),\n    not(\n        activity('CheckEntityExistenceInData').output.exists\n    )\n)",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "CreateParquetTable",
									"type": "SynapseNotebook",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"notebook": {
											"referenceName": "CreateParquetTable",
											"type": "NotebookReference"
										},
										"parameters": {
											"container_name": {
												"value": {
													"value": "@pipeline().parameters.containerName",
													"type": "Expression"
												},
												"type": "string"
											},
											"entity_name": {
												"value": {
													"value": "@pipeline().parameters.entityName",
													"type": "Expression"
												},
												"type": "string"
											}
										},
										"snapshot": true,
										"sparkPool": {
											"referenceName": {
												"value": "@pipeline().parameters.sparkpoolName",
												"type": "Expression"
											},
											"type": "BigDataPoolReference"
										},
										"conf": {
											"spark.dynamicAllocation.enabled": null,
											"spark.dynamicAllocation.minExecutors": null,
											"spark.dynamicAllocation.maxExecutors": null
										},
										"numExecutors": null
									}
								}
							]
						}
					},
					{
						"name": "CheckEntityExistenceInData",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "data_dataset_parquet",
								"type": "DatasetReference",
								"parameters": {
									"containerName": {
										"value": "@pipeline().parameters.containerName",
										"type": "Expression"
									},
									"entityName": {
										"value": "@pipeline().parameters.entityName",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"exists"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					},
					"deleteDeltas": {
						"type": "bool",
						"defaultValue": false
					},
					"sparkpoolName": {
						"type": "string"
					}
				},
				"variables": {
					"dataFormat": {
						"type": "String"
					},
					"traitReferencePrefix": {
						"type": "String",
						"defaultValue": "is.partition.format."
					},
					"traitReference": {
						"type": "String"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/Consolidation_flow')]",
				"[concat(variables('workspaceId'), '/datasets/data_dataset')]",
				"[concat(variables('workspaceId'), '/datasets/dataManifest_dataset')]",
				"[concat(variables('workspaceId'), '/datasets/staging_dataset')]",
				"[concat(variables('workspaceId'), '/datasets/entity_dataset')]",
				"[concat(variables('workspaceId'), '/datasets/data_dataset_parquet')]",
				"[concat(variables('workspaceId'), '/datasets/deltas_dataset')]",
				"[concat(variables('workspaceId'), '/notebooks/CreateParquetTable')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/dataManifest_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "data.manifest.cdm.json",
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/data_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('data/', dataset().entityName)",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/data_dataset_parquet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('data/', dataset().entityName)",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/deltasManifest_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "deltas.manifest.cdm.json",
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/deltas_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('deltas/', dataset().entityName)",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/entity_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().entityName, '.cdm.json')",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/staging_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"containerName": {
						"type": "string"
					},
					"entityName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('staging/', dataset().entityName)",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().containerName",
							"type": "Expression"
						}
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureDataLakeStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "The data lake storage holds the data exported from Dynamics 365 Business Central.",
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('AzureDataLakeStorage_properties_typeProperties_url')]",
					"tenant": "[parameters('AzureDataLakeStorage_properties_typeProperties_tenant')]",
					"servicePrincipalId": "[parameters('AzureDataLakeStorage_properties_typeProperties_servicePrincipalId')]",
					"servicePrincipalCredentialType": "ServicePrincipalKey",
					"servicePrincipalCredential": {
						"type": "SecureString",
						"value": "[parameters('AzureDataLakeStorage_servicePrincipalCredential')]"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/roambc-synapse-workspace-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('roambc-synapse-workspace-WorkspaceDefaultSqlServer_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/roambc-synapse-workspace-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('roambc-synapse-workspace-WorkspaceDefaultStorage_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/bc2adlstrigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Week",
						"interval": 1,
						"startTime": "2023-04-25T04:43:00Z",
						"timeZone": "UTC",
						"schedule": {
							"weekDays": [
								"Wednesday",
								"Monday",
								"Tuesday",
								"Thursday",
								"Friday"
							]
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/IntegrationRuntime1')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "South Africa North",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 10,
							"cleanup": false,
							"customProperties": []
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Consolidation_flow')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"name": "Deltas"
						},
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"name": "CurrentData"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"schemaLinkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"name": "StagingParquet",
							"description": "Writing data as parquet. Column $UniqueRecordKey is not included in output. $Company column is only included if $perCompanyEntity is true."
						},
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"schemaLinkedService": {
								"referenceName": "AzureDataLakeStorage",
								"type": "LinkedServiceReference"
							},
							"name": "StagingCSV",
							"description": "Writing data as CSV. Column $UniqueRecordKey is not included in output. $Company column is only included if $perCompanyEntity is true."
						}
					],
					"transformations": [
						{
							"name": "FilterForDeleted"
						},
						{
							"name": "RemoveDeleted"
						},
						{
							"name": "SortByTimestamp"
						},
						{
							"name": "PickLastChanges"
						},
						{
							"name": "CombineWithDeltas"
						},
						{
							"name": "FilterEmptyRows"
						},
						{
							"name": "DataFormatCondition"
						},
						{
							"name": "CurrentDataWithUniqueRecordKey"
						},
						{
							"name": "DeltasWithUniqueRecordKey"
						}
					],
					"script": "parameters{\n\tcontainerName as string,\n\tentityName as string,\n\tdataFormat as string,\n\tperCompanyEntity as boolean\n}\nsource(output(\n\t\t{timestamp-0} as long,\n\t\t{systemId-2000000000} as string,\n\t\t{SystemCreatedAt-2000000001} as timestamp,\n\t\t{$Company} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: true,\n\tentity: ($entityName),\n\tformat: 'cdm',\n\tmanifestType: 'manifest',\n\tmanifestName: 'deltas',\n\tlocal: true,\n\tfolderPath: '',\n\tfileSystem: ($containerName),\n\ttimestampFormats: ['yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\'']) ~> Deltas\nsource(output(\n\t\t{timestamp-0} as long,\n\t\t{systemId-2000000000} as string,\n\t\t{SystemCreatedAt-2000000001} as timestamp,\n\t\t{$Company} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: true,\n\tentity: ($entityName),\n\tformat: 'cdm',\n\tmanifestType: 'manifest',\n\tmanifestName: 'data',\n\tlocal: true,\n\tfolderPath: '',\n\tfileSystem: ($containerName),\n\ttimestampFormats: ['yyyy-MM-dd HH:mm:ss','yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\'']) ~> CurrentData\nDeltasWithUniqueRecordKey filter(isNull({SystemCreatedAt-2000000001})) ~> FilterForDeleted\nCombineWithDeltas, FilterForDeleted exists(CombineWithDeltas@{$UniqueRecordKey} == DeltasWithUniqueRecordKey@{$UniqueRecordKey},\n\tnegate:true,\n\tbroadcast: 'auto')~> RemoveDeleted\nFilterEmptyRows sort(desc({timestamp-0}, false)) ~> SortByTimestamp\nSortByTimestamp aggregate(groupBy({$UniqueRecordKey}),\n\teach(match(name!='$UniqueRecordKey'), $$ = first($$))) ~> PickLastChanges\nDeltasWithUniqueRecordKey, CurrentDataWithUniqueRecordKey union(byName: true)~> CombineWithDeltas\nRemoveDeleted filter(not(isNull({systemId-2000000000}))) ~> FilterEmptyRows\nPickLastChanges split(equals($dataFormat, 'parquet'),\n\tequals($dataFormat, 'CSV'),\n\tdisjoint: false) ~> DataFormatCondition@(ParquetStaging, CSVStaging)\nCurrentData derive({$UniqueRecordKey} = concat({systemId-2000000000}, iif($perCompanyEntity, {$Company}, \"\"))) ~> CurrentDataWithUniqueRecordKey\nDeltas derive({$UniqueRecordKey} = concat({systemId-2000000000}, iif($perCompanyEntity, {$Company}, \"\"))) ~> DeltasWithUniqueRecordKey\nDataFormatCondition@ParquetStaging sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tfileSystem: ($containerName),\n\tfolderPath: (concat('staging/', $entityName)),\n\tcompressionCodec: 'snappy',\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\teach(match(iif(name=='$UniqueRecordKey',false(),iif(name=='$Company',$perCompanyEntity==true(),true()))))\n\t),\n\tmanifestType: 'manifest') ~> StagingParquet\nDataFormatCondition@CSVStaging sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'delimited',\n\tfileSystem: ($containerName),\n\tfolderPath: (concat('staging/', $entityName)),\n\tcolumnDelimiter: ',',\n\tescapeChar: '\\\\',\n\tquoteChar: '\\\"',\n\tcolumnNamesAsHeader: true,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\teach(match(iif(name=='$UniqueRecordKey',false(),iif(name=='$Company',$perCompanyEntity==true(),true()))))\n\t),\n\tmanifestType: 'manifest') ~> StagingCSV"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/AzureDataLakeStorage')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateParquetTable')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "4aacc607-65f4-4644-9287-c5bf212f559f"
					}
				},
				"metadata": {
					"saveOutput": false,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create an external Spark table based on existing parquet files on the data lake\r\n",
							"\r\n",
							"When executed, this notebook creates a shared metadata table in a Synapse lake database. This table is managed in Spark, but can also be queried using Synapse Serverless SQL. [Read more about shared metadata tables](https://learn.microsoft.com/en-us/azure/synapse-analytics/metadata/table).\r\n",
							"\r\n",
							"The table created by this notebook is an external table, meaning that it is based on existing data on the data lake. Data is not copied or duplicated when creating the table. The notebook will create a database with the name of the data lake container, if it does not exist yet. If a table with the same name already exists, no new table will be created.\r\n",
							"\r\n",
							"This notebook is primarily meant to be run by the Consolidation_OneEntity pipeline. If you are running the notebook manually, make sure to uncomment and fill in the parameters in the next cell."
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# These parameters are automatically provided by the calling pipeline. Uncomment and provide parameters if run manually!\r\n",
							"# container_name = ''\r\n",
							"# entity_name = ''"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Retrieve storage account name from Linked Service\r\n",
							"\r\n",
							"import re\r\n",
							"import json\r\n",
							"linked_service_name = 'AzureDataLakeStorage'\r\n",
							"linked_service_props = mssparkutils.credentials.getPropertiesAll(linked_service_name)\r\n",
							"ls_props_json = json.loads(linked_service_props)\r\n",
							"ls_endpoint = ls_props_json['Endpoint']\r\n",
							"print(f'Found endpoint {ls_endpoint}')\r\n",
							"re_match = re.search('https://(.*).dfs.core.windows.net', ls_endpoint)\r\n",
							"storage_account_name = re_match.group(1)"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create database\r\n",
							"\r\n",
							"db_name = re.sub('[^a-zA-Z0-9_]', '_', container_name) # remove invalid characters and replace them with underscores\r\n",
							"query = f'CREATE DATABASE IF NOT EXISTS `{db_name}`'\r\n",
							"spark.sql(query)"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create table\r\n",
							"\r\n",
							"table_name = re.sub('[^a-zA-Z0-9_]', '_', entity_name) # remove invalid characters and replace them with underscores\r\n",
							"location = f'abfss://{container_name}@{storage_account_name}.dfs.core.windows.net/data/{entity_name}/'\r\n",
							"query = f'CREATE TABLE IF NOT EXISTS `{db_name}`.`{table_name}` USING Parquet LOCATION \"{location}\"'\r\n",
							"spark.sql(query)"
						],
						"outputs": [],
						"execution_count": 2
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/bc2adlsexport')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 15
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": 10,
					"minNodeCount": 3
				},
				"nodeCount": 10,
				"nodeSize": "Small",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.3",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": false,
				"annotations": []
			},
			"dependsOn": [],
			"location": "southafricanorth"
		},
		{
			"name": "[concat(parameters('workspaceName'), '/bc2adlsegion')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 15
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": 16,
					"minNodeCount": 3
				},
				"nodeCount": 10,
				"nodeSize": "XLarge",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.3",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": false,
				"annotations": []
			},
			"dependsOn": [],
			"location": "southafricanorth"
		}
	]
}